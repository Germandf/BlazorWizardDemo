@inject IJSRuntime JS

<div class="wizard-content" style="max-width: @GetMaxWidth();">
    <header class="wizard-header">
        <h1 class="wizard-title">
            @Title
        </h1>
        <p class="wizard-subheading">
            @SubTitle
        </p>
        <div class="wizard-steps">
            <nav class="steps" @ref="_stepsElement">
                @foreach (var step in _steps)
                {
                    <div class="step @(step.IsCompleted ? "completed" : "")">
                        <div class="step-content">
                            @if (_steps.First() == step)
                            {
                                <div class="line background left"></div>
                                <div class="line progress left"></div>
                            }

                            <p class="step-number"><i class="@step.IconClass"></i></p>
                            <svg class="checkmark" viewBox="0 0 52 52">
                                <circle class="checkmark-circle" cx="26" cy="26" r="25" fill="none" />
                                <path class="checkmark-check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" />
                            </svg>

                            <div class="line background @GetLastClass(step)"></div>
                            <div class="line progress @GetLastClass(step)"></div>
                        </div>
                    </div>
                }
            </nav>
        </div>
    </header>

    <div class="panels" style="min-height: @GetMinHeight()">
        @foreach (var panel in _steps)
        {
            <div class="panel @(panel.IsActive && !panel.IsCompleted ? "moving-in" : panel.MovementClass)">
                @panel.ChildContent
            </div>
        }
        <div class="panel @(_steps.All(x => x.IsCompleted) ? "moving-in" : "moving-out-forward")">
            @Completed
        </div>
    </div>

    <div class="wizard-footer">
        <div class="steps-count">
            Step @(_currentStep + 1) of @_steps.Count
        </div>
        <div class="wizard-buttons">
            <button class="button previous"
                    disabled="@GetPreviousDisabled()"
                    @onclick="Previous">
                Previous
            </button>
            <button class="button next"
                    disabled="@GetNextDisabled()"
                    @onclick="Next">
                @GetNextText()
            </button>
        </div>
    </div>
</div>

<CascadingValue Value="this">
    @Steps
</CascadingValue>

@code {

    [Parameter, EditorRequired]
    public required RenderFragment Steps { get; set; }

    [Parameter, EditorRequired]
    public required RenderFragment Completed { get; set; }

    [Parameter, EditorRequired]
    public required string Title { get; set; }

    [Parameter, EditorRequired]
    public required string SubTitle { get; set; }

    [Parameter]
    public string? MinHeight { get; set; }

    [Parameter]
    public string? MaxWidth { get; set; }

    private List<WizardStep> _steps { get; set; } = new();
    private ElementReference _stepsElement;
    private int _currentStep = 0;
    private bool _isLoading;

    private string GetMinHeight() => string.IsNullOrEmpty(MinHeight) ? "auto" : MinHeight;

    private string GetMaxWidth() => string.IsNullOrEmpty(MaxWidth) ? "auto" : MaxWidth;

    private string? GetLastClass(WizardStep step) => _steps.Last() == step ? "right" : null;

    private bool GetPreviousDisabled()
    {
        if (_isLoading || _currentStep < 1) return true;
        var step = _steps[_currentStep];
        return step.IsCompleted || step.EnablePrevious is false;
    }

    private bool GetNextDisabled() => _isLoading || _steps.All(x => x.IsCompleted);

    private string GetNextText() => _isLoading ? "Loading..." : _currentStep == _steps.Count - 1 ? "Finalize" : "Next";

    public void AddStep(WizardStep step, int? position = null)
    {
        if (position is not null && position >= 0 && position < _steps.Count && _steps[position.Value].IsCompleted is false)
        {
            _steps.Insert(position.Value, step);
        }
        else
        {
            _steps.Add(step);
        }
        UpdateSteps();
        StateHasChanged();
    }

    public void RemoveStep(WizardStep step)
    {
        _steps.Remove(step);
        UpdateSteps();
        StateHasChanged();
    }

    private async Task Next()
    {
        var onNext = _steps[_currentStep].OnNext;
        if (onNext is not null)
        {
            _isLoading = true;
            var success = await onNext.Invoke();
            _isLoading = false;
            if (success is false)
            {
                return;
            }
        }
        _steps[_currentStep].IsCompleted = true;
        if (_currentStep < _steps.Count - 1)
        {
            _currentStep++;
        }
        UpdateSteps();
        await HandleScrolls();
    }

    private async Task Previous()
    {
        if (_currentStep > 0)
        {
            _currentStep--;
            _steps[_currentStep].IsCompleted = false;
            UpdateSteps();
            await HandleScrolls();
        }
    }

    private void UpdateSteps()
    {
        for (int i = 0; i < _steps.Count; i++)
        {
            _steps[i].IsActive = i == _currentStep;
            _steps[i].MovementClass = i <= _currentStep ? "moving-out-backward" : i > _currentStep ? "moving-out-forward" : null;
        }
    }

    protected override void OnInitialized()
    {
        UpdateSteps();
    }

    private async Task HandleScrolls()
    {
        try
        {
            await ScrollToCurrentStepIcon();

            // It helps prevent a race condition the first time, provoking that the scroll is not done.
            // 200 would be enough, but 300 is safer.
            // Awaiting the delay before the scroll icon does not work.
            await Task.Delay(300);

            await ScrollToCurrentStepContent();
        }
        catch
        {
        }
    }

    private async Task ScrollToCurrentStepIcon()
    {
        var stepsToWait = 3;
        if (_currentStep <= stepsToWait) return;
        var pxsToScroll = (_currentStep - stepsToWait) * 70;
        await JS.InvokeVoidAsync("scrollLeft", _stepsElement, pxsToScroll);
    }

    private async Task ScrollToCurrentStepContent()
    {
        var isInViewport = await JS.InvokeAsync<bool>("isElementInViewport", _stepsElement);
        if (!isInViewport)
            await JS.InvokeVoidAsync("scrollToElementStart", _stepsElement);
    }
}
